<article xmlns="http://docbook.org/ns/docbook"
	 xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
	 xml:id="apis"
         version="5.0">
<info>
  <title>APIs</title>
</info>

<para>At the level of this library, you must construct a graph using the
underlying APIs. There’s no “pipeline language” support.
Broadly speaking, there are atomic steps, containers, pipelines (the top-most
container), inputs, outputs, variable bindings, and edges.</para>

<para>You can construct any graph that you like with these nodes and
edges between them. An edge is a connection between an “output port”
on a “source” node and an “input port” on a “destination” node. The edges
are arbitrary; asserting that an edge exists between two ports creates
the ports if necessary. (Some steps impose constraints on the ports that
can be used, those constraints are enforced.)</para>

<para>For more information,</para>

<itemizedlist>
<listitem>
<simpara>
The <link xlink:href="pipelines">pipeline APIs</link> walk through
some examples of how pipelines are constructed.</simpara>
</listitem>
<listitem>
<simpara>
The <link xlink:href="vocabulary">step vocabulary</link> describes the compound
steps types in more detail.</simpara>
</listitem>
<listitem>
<simpara>
The <link xlink:href="steps">step API</link> outlines the life cycle of
an atomic step.</simpara>
</listitem>
<listitem>
<simpara>
And the <link xlink:href="/apidocs/com/jafpl/">API Docs</link> take you right to the
generated “Scala Doc”.</simpara>
</listitem>
</itemizedlist>

</article>
